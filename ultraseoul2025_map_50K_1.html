<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultraseoul2025 50k - Tracedetrail Custom Map Style</title>
  <meta name="viewport" content="width=1300">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin:0; padding:0; background:#f8f8f8; }
    #container {
      width: 1300px;
      margin: 24px auto 0;
    }
    #map {
      width: 1300px;
      height: 731px; /* 1300 * 9/16 */
      filter: saturate(0.5) brightness(1.08) contrast(1.04); /* 채도 낮추고 살짝 밝게 */
      border-radius: 12px;
      box-shadow: 0 3px 16px rgba(0,0,0,0.07);
      background: #ececec;
      position: relative;
      z-index: 1;
      overflow: hidden;
    }
    #elevationBox {
      width: 1300px;
      height: 160px;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      margin-top: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      z-index: 1;
    }
    #elevation {
      width: 1250px !important;
      height: 140px !important;
      margin: 0 0 0 0;
      display: block;
    }
    #infoBox {
      position: absolute;
      top: 18px; right: 24px;
      background: rgba(255,255,255,0.97);
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 1.08em;
      font-weight: 400;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.13);
      min-width: 180px;
      text-align: right;
      pointer-events: none;
    }
    .km-label {
      color: white;
      font-weight: bold;
      font-size: 15px;
      text-align: center;
      text-shadow: 0 2px 4px #000, 0 0px 2px #e23;
      pointer-events: none;
    }
    /* 지도 컨트롤 등 최대한 흐리게 */
    .leaflet-control-attribution { opacity: 0.15; }
    .leaflet-control-zoom { opacity: 0.7; }
  </style>
</head>
<body>
  <div id="container">
    <div id="map">
      <div id="infoBox">마우스를 코스 위에 올려보세요.</div>
    </div>
    <div id="elevationBox">
      <canvas id="elevation"></canvas>
    </div>
  </div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js"></script>
  <script>
  const gpxUrl = './ultraseoul2025_50k_gm.gpx';

  // 지도 설정
  const map = L.map('map', {
    dragging: true,
    scrollWheelZoom: false,
    doubleClickZoom: false,
    boxZoom: false,
    touchZoom: false,
    keyboard: false,
    zoomControl: true, // 확대/축소는 허용
    attributionControl: true,
  }).setView([37.6413, 127.1116], 13);

  // 지도 이동 제한 (드래그만 허용)
  map.scrollWheelZoom.disable();
  map.touchZoom.disable();
  map.doubleClickZoom.disable();
  map.boxZoom.disable();
  map.keyboard.disable();

  // 지도 타일 (채도 낮춘 OSM 기본타일, 도로/지명 등 최대한 흐릿하게)
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: '© OpenStreetMap',
    opacity: 0.52, // 살짝 흐릿하게
    detectRetina: true
  }).addTo(map);

  let chart, elevations = [], distances = [], latlngs = [];
  let highlightMarker;
  let polyline;
  let kmMarkers = [];

  fetch(gpxUrl)
    .then(res => res.text())
    .then(xmlText => {
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlText, "application/xml");
      const trkpts = xml.querySelectorAll('trkpt');
      latlngs = [];
      elevations = [];
      distances = [0];
      trkpts.forEach((pt, i) => {
        const lat = parseFloat(pt.getAttribute('lat'));
        const lon = parseFloat(pt.getAttribute('lon'));
        const ele = parseFloat(pt.querySelector('ele').textContent);
        latlngs.push([lat, lon]);
        elevations.push(ele);
        if(i > 0) {
          distances[i] = distances[i-1] + getDistance(
            latlngs[i-1][0], latlngs[i-1][1],
            lat, lon
          );
        }
      });

      polyline = L.polyline(latlngs, {
        color: '#FF3D00',
        weight: 5,
        opacity: 0.91,
        lineCap: 'round'
      }).addTo(map);
      map.fitBounds(polyline.getBounds(), {padding:[10,10]});

      drawKmMarkers();

      polyline.on('mousemove', function(e) {
        const idx = getClosestIndex(e.latlng, latlngs);
        highlightOnMap(idx);
        showInfo(idx);
        chart.setActiveElements([{datasetIndex:0, index:idx}]);
        chart.update('none');
      });
      polyline.on('mouseout', function() {
        removeHighlight();
        hideInfo();
        chart.setActiveElements([]);
        chart.update('none');
      });

      drawElevationChart();
    });

  // 5km 단위 마커
  function drawKmMarkers() {
    const totalKm = (distances[distances.length-1]/1000);
    for(let k=5; k<=Math.floor(totalKm)+1; k+=5) {
      const idx = distances.findIndex(d => d/1000 >= k);
      if(idx !== -1) {
        const marker = L.circleMarker(latlngs[idx], {
          radius: 15,
          color: '#d32f2f',
          fillColor: '#d32f2f',
          fillOpacity: 1,
          weight: 2
        }).addTo(map);
        // 하얀 볼드 레이블
        const div = L.divIcon({
          className: "km-label",
          html: `<span>${k}</span>`,
          iconSize: [22,22],
          iconAnchor: [11,11]
        });
        const label = L.marker(latlngs[idx], {
          icon: div,
          interactive: false
        }).addTo(map);
        kmMarkers.push(marker, label);
      }
    }
  }

  // 고도표
  function drawElevationChart() {
    const kmArr = distances.map(m => (m/1000).toFixed(2));
    const ctx = document.getElementById('elevation').getContext('2d');
    if(chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: kmArr,
        datasets: [{
          label: '고도(m)',
          data: elevations,
          borderColor: '#1976d2',
          backgroundColor: 'rgba(25,118,210,0.18)',
          pointRadius: 0,
          fill: true,
          tension: 0.15
        }]
      },
      options: {
        responsive: false,
        maintainAspectRatio: false,
        plugins: { legend: { display: false }},
        scales: {
          x: { display: true, title: { display: true, text: '거리 (km)'} },
          y: { display: true, title: { display: true, text: '고도 (m)'} }
        },
        interaction: {
          mode: 'index',
          intersect: false
        },
        onHover: (event, chartElements) => {
          if(chartElements.length) {
            const i = chartElements[0].index;
            highlightOnMap(i);
            showInfo(i);
          }
        },
        onLeave: () => {
          removeHighlight();
          hideInfo();
        }
      }
    });

    ctx.canvas.addEventListener('mousemove', (e) => {
      const points = chart.getElementsAtEventForMode(e, 'index', {intersect:false}, false);
      if(points.length) {
        const idx = points[0].index;
        highlightOnMap(idx);
        showInfo(idx);
      }
    });
    ctx.canvas.addEventListener('mouseleave', () => {
      removeHighlight();
      hideInfo();
    });
  }

  // 지도상 하이라이트
  function highlightOnMap(idx) {
    if(!latlngs[idx]) return;
    if(highlightMarker) map.removeLayer(highlightMarker);
    highlightMarker = L.circleMarker(latlngs[idx], {
      radius: 8,
      color: '#0d47a1',
      fillColor: '#fff',
      fillOpacity: 1,
      weight: 2
    }).addTo(map);
  }
  function removeHighlight() {
    if(highlightMarker) map.removeLayer(highlightMarker);
  }

  function showInfo(idx) {
    const dist = (distances[idx]/1000).toFixed(2);
    const ele = elevations[idx].toFixed(1);
    const lat = latlngs[idx][0].toFixed(6);
    const lon = latlngs[idx][1].toFixed(6);
    document.getElementById('infoBox').innerHTML =
      `<b>거리:</b> ${dist} km<br/><b>고도:</b> ${ele} m<br/><b>좌표:</b> ${lat}, ${lon}`;
  }
  function hideInfo() {
    document.getElementById('infoBox').innerHTML = '마우스를 코스 위에 올려보세요.';
  }

  function getClosestIndex(latlng, arr) {
    let minD = 1e9, idx = 0;
    arr.forEach((p,i)=>{
      const d = map.distance(latlng, p);
      if(d < minD) { minD = d; idx = i; }
    });
    return idx;
  }
  function getDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }
  </script>
</body>
</html>
