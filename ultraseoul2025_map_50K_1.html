<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultraseoul2025 50k - Tracedetrail Simple Map Style (Grayscale)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin:0; padding:0; }
    #map { height: 60vh; }
    #elevation { height: 30vh; }
    #infoBox {
      position: absolute;
      top: 10px; right: 10px;
      background: rgba(255,255,255,0.95);
      border-radius: 8px;
      padding: 7px 14px;
      font-size: 1em;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25);
    }
    #elevationBox {
      text-align: center;
      margin: 12px 0 0 0;
      font-size: 1em;
    }
    .km-label {
      color: white;
      font-weight: bold;
      font-size: 15px;
      text-align: center;
      text-shadow: 0 2px 4px #000, 0 0px 2px #e23;
      pointer-events: none;
    }
    /* 지도 컨트롤 등도 최대한 숨김효과 */
    .leaflet-control-attribution { opacity: 0.25; }
    .leaflet-control-zoom { opacity: 0.85; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="elevationBox">
    <canvas id="elevation"></canvas>
  </div>
  <div id="infoBox">마우스를 코스 위에 올려보세요.</div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js"></script>

  <script>
  // --- GPX 파일 경로 ---
  const gpxUrl = './ultraseoul2025_50k_gm.gpx';

  // --- Grayscale(흑백) 타일 ---
  // CartoDB Positron(흰회색) - 도로·지명 등 최소화, 단순함
  const grayscaleUrl =
    "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png";

  // --- 지도 초기화 ---
  const map = L.map('map').setView([37.6413, 127.1116], 13);
  L.tileLayer(grayscaleUrl, {
    maxZoom: 18,
    attribution: '© OpenStreetMap & CartoDB',
    opacity: 0.90 // 살짝 연하게
  }).addTo(map);

  let chart, elevations = [], distances = [], latlngs = [];
  let highlightMarker;
  let polyline;
  let kmMarkers = [];

  // --- GPX 직접 파싱 및 데이터 추출 ---
  fetch(gpxUrl)
    .then(res => res.text())
    .then(xmlText => {
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlText, "application/xml");
      const trkpts = xml.querySelectorAll('trkpt');
      latlngs = [];
      elevations = [];
      distances = [0];
      trkpts.forEach((pt, i) => {
        const lat = parseFloat(pt.getAttribute('lat'));
        const lon = parseFloat(pt.getAttribute('lon'));
        const ele = parseFloat(pt.querySelector('ele').textContent);
        latlngs.push([lat, lon]);
        elevations.push(ele);
        if(i > 0) {
          distances[i] = distances[i-1] + getDistance(
            latlngs[i-1][0], latlngs[i-1][1],
            lat, lon
          );
        }
      });

      // --- Polyline 표시 (빨간색만 강조) ---
      polyline = L.polyline(latlngs, {
        color: '#FF3D00',
        weight: 5,
        opacity: 0.88,
        lineCap: 'round'
      }).addTo(map);
      map.fitBounds(polyline.getBounds());

      // --- 5km 구간 마커 표시 ---
      drawKmMarkers();

      // --- Polyline 마우스오버 이벤트 (지도 상) ---
      polyline.on('mousemove', function(e) {
        const idx = getClosestIndex(e.latlng, latlngs);
        highlightOnMap(idx);
        showInfo(idx);
        chart.setActiveElements([{datasetIndex:0, index:idx}]);
        chart.update('none');
      });
      polyline.on('mouseout', function() {
        removeHighlight();
        hideInfo();
        chart.setActiveElements([]);
        chart.update('none');
      });

      // --- 고도 차트 그리기 ---
      drawElevationChart();
    });

  // --- 5km마다 구간마커 ---
  function drawKmMarkers() {
    const totalKm = (distances[distances.length-1]/1000);
    for(let k=5; k<=Math.floor(totalKm)+1; k+=5) {
      const idx = distances.findIndex(d => d/1000 >= k);
      if(idx !== -1) {
        const marker = L.circleMarker(latlngs[idx], {
          radius: 15,
          color: '#d32f2f',
          fillColor: '#d32f2f',
          fillOpacity: 1,
          weight: 2
        }).addTo(map);
        // 하얀색 볼드 숫자 라벨
        const div = L.divIcon({
          className: "km-label",
          html: `<span>${k}</span>`,
          iconSize: [22,22],
          iconAnchor: [11,11]
        });
        const label = L.marker(latlngs[idx], {
          icon: div,
          interactive: false
        }).addTo(map);
        kmMarkers.push(marker, label);
      }
    }
  }

  // --- 고도 차트 (Chart.js) ---
  function drawElevationChart() {
    const kmArr = distances.map(m => (m/1000).toFixed(2));
    const ctx = document.getElementById('elevation').getContext('2d');
    if(chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: kmArr,
        datasets: [{
          label: '고도(m)',
          data: elevations,
          borderColor: '#1976d2',
          backgroundColor: 'rgba(25,118,210,0.18)',
          pointRadius: 0,
          fill: true,
          tension: 0.1
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false }},
        scales: {
          x: { display: true, title: { display: true, text: '거리 (km)'} },
          y: { display: true, title: { display: true, text: '고도 (m)'} }
        },
        interaction: {
          mode: 'index',
          intersect: false
        },
        onHover: (event, chartElements) => {
          if(chartElements.length) {
            const i = chartElements[0].index;
            highlightOnMap(i);
            showInfo(i);
          }
        },
        onLeave: () => {
          removeHighlight();
          hideInfo();
        }
      }
    });

    // 차트 마우스 이동시 지도 연동
    ctx.canvas.addEventListener('mousemove', (e) => {
      const points = chart.getElementsAtEventForMode(e, 'index', {intersect:false}, false);
      if(points.length) {
        const idx = points[0].index;
        highlightOnMap(idx);
        showInfo(idx);
      }
    });
    ctx.canvas.addEventListener('mouseleave', () => {
      removeHighlight();
      hideInfo();
    });
  }

  // 지도상 하이라이트
  function highlightOnMap(idx) {
    if(!latlngs[idx]) return;
    if(highlightMarker) map.removeLayer(highlightMarker);
    highlightMarker = L.circleMarker(latlngs[idx], {
      radius: 8,
      color: '#0d47a1',
      fillColor: '#fff',
      fillOpacity: 1,
      weight: 2
    }).addTo(map);
  }
  function removeHighlight() {
    if(highlightMarker) map.removeLayer(highlightMarker);
  }

  // 정보 박스
  function showInfo(idx) {
    const dist = (distances[idx]/1000).toFixed(2);
    const ele = elevations[idx].toFixed(1);
    const lat = latlngs[idx][0].toFixed(6);
    const lon = latlngs[idx][1].toFixed(6);
    document.getElementById('infoBox').innerHTML =
      `<b>거리:</b> ${dist} km<br/><b>고도:</b> ${ele} m<br/><b>좌표:</b> ${lat}, ${lon}`;
  }
  function hideInfo() {
    document.getElementById('infoBox').innerHTML = '마우스를 코스 위에 올려보세요.';
  }

  // polyline에서 가장 가까운 index
  function getClosestIndex(latlng, arr) {
    let minD = 1e9, idx = 0;
    arr.forEach((p,i)=>{
      const d = map.distance(latlng, p);
      if(d < minD) { minD = d; idx = i; }
    });
    return idx;
  }
  // 거리계산 (Haversine, m)
  function getDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }
  </script>
</body>
</html>
